#!/bin/sh

#=========================================================================
#
#  Program:   CMake - Cross-Platform Makefile Generator
#  Module:    $RCSfile$
#  Language:  Bourne Shell
#  Date:      $Date$
#  Version:   $Revision$
#
#  Copyright (c) 2002 Kitware, Inc., Insight Consortium.  All rights reserved.
#  See Copyright.txt or http://www.cmake.org/HTML/Copyright.html for details.
#
#     This software is distributed WITHOUT ANY WARRANTY; without even 
#     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
#     PURPOSE.  See the above copyright notices for more information.
#
#=========================================================================

CMAKE_KNOWN_C_COMPILERS="cc gcc xlc icc tcc"
CMAKE_KNOWN_CXX_COMPILERS="CC g++ c++ xlC icc como aCC"
CMAKE_KNOWN_MAKE_PROCESSORS="make gmake"

CMAKE_CXX_SOURCES="\
  cmake  \
  cmakewizard  \
  cmakemain \
  cmMakeDepend \
  cmMakefile \
  cmDocumentation \
  cmGlob \
  cmGlobalGenerator \
  cmLocalGenerator \
  cmSourceFile \
  cmSystemTools \
  cmGlobalUnixMakefileGenerator \
  cmLocalUnixMakefileGenerator \
  cmCommands \
  cmTarget \
  cmCustomCommand \
  cmCacheManager \
  cmListFileCache \
  cmVariableWatch \
  cmSourceGroup"

CMAKE_C_SOURCES="\
  cmListFileLexer \
  "

KWSYS_C_SOURCES="\
  ProcessUNIX"

KWSYS_CXX_SOURCES="\
  Directory \
  RegularExpression \
  SystemTools"

KWSYS_FILES="\
  Directory.hxx \
  Process.h \
  RegularExpression.hxx \
  SystemTools.hxx"

KWSYS_IOS_FILES="
  fstream \
  iosfwd \
  iostream \
  sstream"

cmake_system=`uname`

cmake_source_dir=`echo $0 | sed -n '/\//{s/\/[^\/]*$//;p;}'`
cmake_source_dir=`(cd "${cmake_source_dir}";pwd)`
cmake_binary_dir=`pwd`
cmake_bootstrap_dir="${cmake_binary_dir}/Bootstrap.cmk"
cmake_data_dir="/share/CMake"
cmake_doc_dir="/doc/CMake"
cmake_man_dir="/man"
cmake_init_file=""

# Display CMake bootstrap usage
cmake_usage()
{
  cat <<EOF
Usage: $0 [options]
Options: [defaults in brackets after descriptions]
Configuration:
  --help                  print this message
  --version               only print version information
  --verbose               display more information
  --parallel=n            bootstrap cmake in parallel, where n is
                          number of nodes [1]
  --init=FILE             use FILE for cmake initialization

Directory and file names:
  --prefix=PREFIX         install files in tree rooted at PREFIX
                          [/usr/local]
  --datadir=DIR           install data files in PREFIX/DIR
                          [/share/CMake]
  --docdir=DIR            install documentation files in PREFIX/DIR
                          [/doc/CMake]
  --mandir=DIR            install man pages files in PREFIX/DIR/manN
                          [/man]
EOF
  exit 10
}

# Display CMake bootstrap usage
cmake_version()
{
  # Get CMake version
  CMAKE_VERSION=""
  for a in MAJOR MINOR PATCH; do
    CMake_VERSION=`cat "${cmake_source_dir}/CMakeLists.txt" | \
      grep "SET(CMake_VERSION_${a} *[0-9]*)" | sed "s/SET(CMake_VERSION_${a} *\([0-9]*\))/\1/"`
    CMAKE_VERSION="${CMAKE_VERSION}.${CMake_VERSION}" 
  done
  CMAKE_VERSION=`echo $CMAKE_VERSION | sed "s/\.\([0-9][0-9]*\)\.\([0-9][0-9]*\)\.\([0-9][0-9]*\)/\1.\2-\3/"`
  echo "CMake ${CMAKE_VERSION}, Copyright (c) 2002 Kitware, Inc., Insight Consortium"
}

# Display CMake bootstrap error, display the log file and exit
cmake_error()
{
  res=$1
  shift 1
  echo "---------------------------------------------"
  echo "Error when bootstrapping CMake:" 
  echo "$*"
  echo "---------------------------------------------"
  if [ -f cmake_bootstrap.log ]; then
    echo "Log of errors: `pwd`/cmake_bootstrap.log"
    #cat cmake_bootstrap.log
    echo "---------------------------------------------"
  fi
  exit ${res}
}

# Replace KWSYS_NAMESPACE with cmsys
cmake_replace_string ()
{
  INFILE="$1"
  OUTFILE="$2"
  SEARCHFOR="$3"
  REPLACEWITH="$4"
  if [ -f "${INFILE}" ]; then
    cat "${INFILE}" | 
      sed "s/\@${SEARCHFOR}\@/${REPLACEWITH}/g" > "${OUTFILE}.tmp"
    if [ -f "${OUTFILE}.tmp" ]; then
      if diff "${OUTFILE}" "${OUTFILE}.tmp" > /dev/null 2> /dev/null ; then
        #echo "Files are the same"
        rm -f "${OUTFILE}.tmp"
      else
        mv -f "${OUTFILE}.tmp" "${OUTFILE}"
      fi
    fi
  else
    cmake_error 1 "Cannot find file ${INFILE}"
  fi
}

cmake_kwsys_config_replace_string ()
{
  INFILE="$1"
  OUTFILE="$2"
  shift 2
  APPEND="$*"
  if [ -f "${INFILE}" ]; then
    echo "${APPEND}" > "${OUTFILE}.tmp"
    cat "${INFILE}" | 
      sed "/./ {s/\@KWSYS_NAMESPACE\@/cmsys/g;
                s/@KWSYS_BUILD_SHARED@/${KWSYS_BUILD_SHARED}/g;
                s/@KWSYS_NAME_IS_KWSYS@/${KWSYS_NAME_IS_KWSYS}/g;
                s/@KWSYS_IOS_USE_ANSI@/${KWSYS_IOS_USE_ANSI}/g;
                s/@KWSYS_IOS_HAVE_STD@/${KWSYS_IOS_HAVE_STD}/g;
                s/@KWSYS_IOS_USE_SSTREAM@/${KWSYS_IOS_USE_SSTREAM}/g;
                s/@KWSYS_IOS_USE_STRSTREAM_H@/${KWSYS_IOS_USE_STRSTREAM_H}/g;
                s/@KWSYS_IOS_USE_STRSTREA_H@/${KWSYS_IOS_USE_STRSTREA_H}/g;
                s/@KWSYS_STL_HAVE_STD@/${KWSYS_STL_HAVE_STD}/g;}" >> "${OUTFILE}.tmp"
    if [ -f "${OUTFILE}.tmp" ]; then
      if diff "${OUTFILE}" "${OUTFILE}.tmp" > /dev/null 2> /dev/null ; then
        #echo "Files are the same"
        rm -f "${OUTFILE}.tmp"
      else
        mv -f "${OUTFILE}.tmp" "${OUTFILE}"
      fi
    fi
  else
    cmake_error 2 "Cannot find file ${INFILE}"
  fi
}
# Write string into a file
cmake_report ()
{
  FILE=$1
  shift
  echo "$*" >> ${FILE}
}

# Escape spaces in strings
cmake_escape ()
{
  echo $1 | sed "s/ /\\\\ /g"
}

# Write message to the log
cmake_log ()
{
  echo "$*" >> cmake_bootstrap.log
}

# Return temp file
cmake_tmp_file ()
{
  echo "cmake_bootstrap_$$.test"
}

# Run a compiler test. First argument is compiler, second one are compiler
# flags, third one is test source file to be compiled
cmake_try_run ()
{
  COMPILER=$1
  FLAGS=$2
  TESTFILE=$3
  if [ ! -f "${TESTFILE}" ]; then
    echo "Test file ${TESTFILE} missing. Please verify your CMake source tree."
    exit 4
  fi
  TMPFILE=`cmake_tmp_file`
  echo "Try: ${COMPILER}"
  echo "Line: ${COMPILER} ${FLAGS} ${TESTFILE} -o ${TMPFILE}"
  echo "----------  file   -----------------------"
  cat ${TESTFILE}
  echo "------------------------------------------"
  "${COMPILER}" ${FLAGS} "${TESTFILE}" -o "${TMPFILE}"
  RES=$?
  if [ "${RES}" -ne "0" ]; then
    echo "Test failed to compile"
    return 1
  fi
  if [ ! -f "${TMPFILE}" ] && [ ! -f "${TMPFILE}.exe" ]; then
    echo "Test failed to produce executable"
    return 2
  fi
  ./${TMPFILE}
  RES=$?
  rm -f "${TMPFILE}"
  if [ "${RES}" -ne "0" ]; then
    echo "Test produced non-zero return code"
    return 3
  fi
  echo "Test succeded"
  return 0
}

# Run a make test. First argument is the make interpreter.
cmake_try_make ()
{
  MAKE_PROC="$1"
  MAKE_FLAGS="$2"
  echo "Try: ${MAKE_PROC}"
  "${MAKE_PROC}" ${MAKE_FLAGS}
  RES=$?
  if [ "${RES}" -ne "0" ]; then
    echo "${MAKE_PROC} does not work"
    return 1
  fi
  if [ ! -f "test" ] && [ ! -f "test.exe" ]; then
    echo "${COMPILER} does not produce output"
    return 2
  fi
  ./test
  RES=$?
  rm -f "test"
  if [ "${RES}" -ne "0" ]; then
    echo "${MAKE_PROC} produces strange executable"
    return 3
  fi
  echo "${MAKE_PROC} works"
  return 0
}

# Parse arguments
cmake_verbose=
cmake_parallel_make=
cmake_prefix_dir="/usr/local"
for a in "$@"; do
  if echo $a | grep "^--prefix=" > /dev/null 2> /dev/null; then
    cmake_prefix_dir=`echo $a | sed "s/^--prefix=//"`
  fi
  if echo $a | grep "^--parallel=" > /dev/null 2> /dev/null; then
    cmake_parallel_make=`echo $a | sed "s/^--parallel=//" | grep "[0-9][0-9]*"`
  fi
  if echo $a | grep "^--datadir=" > /dev/null 2> /dev/null; then
    cmake_data_dir=`echo $a | sed "s/^--datadir=//"`
  fi
  if echo $a | grep "^--docdir=" > /dev/null 2> /dev/null; then
    cmake_doc_dir=`echo $a | sed "s/^--docdir=//"`
  fi
  if echo $a | grep "^--mandir=" > /dev/null 2> /dev/null; then
    cmake_man_dir=`echo $a | sed "s/^--mandir=//"`
  fi
  if echo $a | grep "^--init=" > /dev/null 2> /dev/null; then
    cmake_init_file=`echo $a | sed "s/^--init=//"`
  fi
  if echo $a | grep "^--help" > /dev/null 2> /dev/null; then
    cmake_usage
  fi
  if echo $a | grep "^--version" > /dev/null 2> /dev/null; then
    cmake_version
    exit 2
  fi
  if echo $a | grep "^--verbose" > /dev/null 2> /dev/null; then
    cmake_verbose=TRUE
  fi
done

# If verbose, display some information about bootstrap
if [ -n "${cmake_verbose}" ]; then
  echo "---------------------------------------------"
  echo "Source directory: ${cmake_source_dir}"
  echo "Binary directory: ${cmake_binary_dir}"
  echo "Prefix directory: ${cmake_prefix_dir}"
  echo "System:           ${cmake_system}"
  if [ "x${cmake_parallel_make}" != "x" ]; then
    echo "Doing parallel make: ${cmake_parallel_make}"
  fi
  echo ""
fi

echo "---------------------------------------------"
# Get CMake version
echo "`cmake_version`"

# Make bootstrap directory
[ -d "${cmake_bootstrap_dir}" ] || mkdir "${cmake_bootstrap_dir}"
if [ ! -d "${cmake_bootstrap_dir}" ]; then
  cmake_error 3 "Cannot create directory ${cmake_bootstrap_dir} to bootstrap CMake."
fi
cd "${cmake_bootstrap_dir}"

[ -d "cmsys" ] || mkdir "cmsys"
if [ ! -d "cmsys" ]; then
  cmake_error 4 "Cannot create directory ${cmake_bootstrap_dir}/cmsys"
fi

for a in stl ios; do
  [ -d "cmsys/${a}" ] || mkdir "cmsys/${a}"
  if [ ! -d "cmsys/${a}" ]; then
    cmake_error 5 "Cannot create directory ${cmake_bootstrap_dir}/cmsys/${a}"
  fi
done

# Delete all the bootstrap files
rm -f "${cmake_bootstrap_dir}/cmake_bootstrap.log"
rm -f "${cmake_bootstrap_dir}/cmConfigure.h.tmp"

# If exist compiler flags, set them
cmake_c_flags=${CFLAGS}
cmake_cxx_flags=${CXXFLAGS}

# Test C compiler
cmake_c_compiler=

# If CC is set, use that for compiler, otherwise use list of known compilers
if [ -n "${CC}" ]; then
  cmake_c_compilers="${CC}"
else
  cmake_c_compilers="${CMAKE_KNOWN_C_COMPILERS}"
fi

# Check if C compiler works
TMPFILE=`cmake_tmp_file`
cat > "${TMPFILE}.c" <<EOF
#include<stdio.h>
int main()
{
  printf("1\n");
  return 0;
}
EOF
for a in ${cmake_c_compilers}; do
  if [ -z "${cmake_c_compiler}" ] && \
    cmake_try_run "${a}" "${cmake_c_flags}" "${TMPFILE}.c" >> cmake_bootstrap.log 2>&1; then
    cmake_c_compiler="${a}"
  fi
done
rm -f "${TMPFILE}.c"

if [ -z "${cmake_c_compiler}" ]; then
  cmake_error 6 "Cannot find appropriate C compiler on this system.
Please specify one using environment variable CC."
fi
echo "C compiler on this system is: ${cmake_c_compiler} ${cmake_c_flags}"

# Test CXX compiler
cmake_cxx_compiler=

# On Mac OSX, CC is the same as cc, so make sure not to try CC as c++ compiler.

# If CC is set, use that for compiler, otherwise use list of known compilers
if [ -n "${CXX}" ]; then
  cmake_cxx_compilers="${CXX}"
else
  cmake_cxx_compilers="${CMAKE_KNOWN_CXX_COMPILERS}"
fi

# Check if C++ compiler works
TMPFILE=`cmake_tmp_file`
cat > "${TMPFILE}.cxx" <<EOF
#if defined(TEST1)
# include <iostream>
#else
# include <iostream.h>
#endif

class NeedCXX 
{
public:
  NeedCXX() { this->Foo = 1; }
  int GetFoo() { return this->Foo; }
private:
  int Foo;
};
int main()
{
  NeedCXX c;
#ifdef TEST3
  cout << c.GetFoo() << endl;
#else
  std::cout << c.GetFoo() << std::endl;
#endif
  return 0;
}
EOF
for a in ${cmake_cxx_compilers}; do
  for b in 1 2 3; do
    if [ -z "${cmake_cxx_compiler}" ] && \
      cmake_try_run "${a}" "${cmake_cxx_flags} -DTEST${b}" "${TMPFILE}.cxx" >> cmake_bootstrap.log 2>&1; then
      cmake_cxx_compiler="${a}"
    fi
  done
done
rm -f "${TMPFILE}.cxx"

if [ -z "${cmake_cxx_compiler}" ]; then
  cmake_error 7 "Cannot find appropriate C++ compiler on this system.
Please specify one using environment variable CXX."
fi
echo "C++ compiler on this system is: ${cmake_cxx_compiler} ${cmake_cxx_flags}"

# Test Make

cmake_make_processor=
cmake_make_flags=

# If MAKE is set, use that for make processor, otherwise use list of known make
if [ -n "${MAKE}" ]; then
  cmake_make_processors="${MAKE}"
else
  cmake_make_processors="${CMAKE_KNOWN_MAKE_PROCESSORS}"
fi

TMPFILE="`cmake_tmp_file`_dir"
rm -rf "${cmake_bootstrap_dir}/${TMPFILE}"
mkdir "${cmake_bootstrap_dir}/${TMPFILE}"
cd "${cmake_bootstrap_dir}/${TMPFILE}"
cat>"Makefile"<<EOF
test: test.c
	"${cmake_c_compiler}" -o test test.c
EOF
cat>"test.c"<<EOF
#include <stdio.h>
int main(){ printf("1\n"); return 0; }
EOF
if [ "x${cmake_parallel_make}" != "x" ]; then
  cmake_make_flags="${cmake_make_flags} -j ${cmake_parallel_make}"
fi
for a in ${cmake_make_processors}; do
  if [ -z "${cmake_make_processor}" ] && cmake_try_make "${a}" "${cmake_make_flags}" >> cmake_bootstrap.log 2>&1; then
    cmake_make_processor="${a}"
  fi
done
cd "${cmake_bootstrap_dir}"
rm -rf "${cmake_bootstrap_dir}/${TMPFILE}"

if [ -z "${cmake_make_processor}" ]; then
  cmake_error 8 "Cannot find appropriate Makefile processor on this system.
Please specify one using environment variable MAKE."
fi
echo "Make processor on this system is: ${cmake_make_processor}"

# Ok, we have CC, CXX, and MAKE.

# Test C++ compiler features

# If we are on IRIX, check for -LANG:std
cmake_test_flags="-LANG:std"
if [ "x${cmake_system}" = "xIRIX64" ]; then
  TMPFILE=`cmake_tmp_file`
  cat > ${TMPFILE}.cxx <<EOF
  #include <iostream>
  int main() { std::cout << "No need for ${cmake_test_flags}" << std::endl; return 0;}
EOF
  cmake_need_lang_std=0
  if cmake_try_run "${cmake_cxx_compiler}" \
    "${cmake_cxx_flags}" "${TMPFILE}.cxx" >> cmake_bootstrap.log 2>&1; then
    :
  else
    if cmake_try_run "${cmake_cxx_compiler}" \
      "${cmake_cxx_flags} ${cmake_test_flags}" "${TMPFILE}.cxx" >> cmake_bootstrap.log 2>&1; then
      cmake_need_lang_std=1
    fi
  fi
  if [ "x${cmake_need_lang_std}" = "x1" ]; then
    cmake_cxx_flags="${cmake_cxx_flags} ${cmake_test_flags}"
    echo "${cmake_cxx_compiler} needs ${cmake_test_flags}"
  else
    echo "${cmake_cxx_compiler} does not need ${cmake_test_flags}"
  fi
  rm -f "${TMPFILE}.cxx"
fi
cmake_test_flags=

# If we are on OSF, check for -timplicit_local -no_implicit_include
cmake_test_flags="-timplicit_local -no_implicit_include"
if [ "x${cmake_system}" = "xOSF1" ]; then
  TMPFILE=`cmake_tmp_file`
  cat > ${TMPFILE}.cxx <<EOF
  #include <iostream>
  int main() { std::cout << "We need ${cmake_test_flags}" << std::endl; return 0;}
EOF
  cmake_need_flags=1
  if cmake_try_run "${cmake_cxx_compiler}" \
    "${cmake_cxx_flags} ${cmake_test_flags}" "${TMPFILE}.cxx" >> cmake_bootstrap.log 2>&1; then
    :
  else
    cmake_need_flags=0
  fi
  if [ "x${cmake_need_flags}" = "x1" ]; then
    cmake_cxx_flags="${cmake_cxx_flags} ${cmake_test_flags}"
    echo "${cmake_cxx_compiler} needs ${cmake_test_flags}"
  else
    echo "${cmake_cxx_compiler} does not need ${cmake_test_flags}"
  fi
  rm -f "${TMPFILE}.cxx"
fi
cmake_test_flags=

# If we are on OSF, check for -std strict_ansi -nopure_cname
cmake_test_flags="-std strict_ansi -nopure_cname"
if [ "x${cmake_system}" = "xOSF1" ]; then
  TMPFILE=`cmake_tmp_file`
  cat > ${TMPFILE}.cxx <<EOF
  #include <iostream>
  int main() { std::cout << "We need ${cmake_test_flags}" << std::endl; return 0;}
EOF
  cmake_need_flags=1
  if cmake_try_run "${cmake_cxx_compiler}" \
    "${cmake_cxx_flags} ${cmake_test_flags}" "${TMPFILE}.cxx" >> cmake_bootstrap.log 2>&1; then
    :
  else
    cmake_need_flags=0
  fi
  if [ "x${cmake_need_flags}" = "x1" ]; then
    cmake_cxx_flags="${cmake_cxx_flags} ${cmake_test_flags}"
    echo "${cmake_cxx_compiler} needs ${cmake_test_flags}"
  else
    echo "${cmake_cxx_compiler} does not need ${cmake_test_flags}"
  fi
  rm -f "${TMPFILE}.cxx"
fi
cmake_test_flags=

# If we are on HP-UX, check for -Ae for the C compiler.
cmake_test_flags="-Ae"
if [ "x${cmake_system}" = "xHP-UX" ]; then
  TMPFILE=`cmake_tmp_file`
  cat > ${TMPFILE}.c <<EOF
  int main(int argc, char** argv) { (void)argc; (void)argv; return 0; }
EOF
  cmake_need_Ae=0
  if cmake_try_run "${cmake_c_compiler}" "${cmake_c_flags}" "${TMPFILE}.c" >> cmake_bootstrap.log 2>&1; then
    :
  else
    if cmake_try_run "${cmake_c_compiler}" \
      "${cmake_c_flags} ${cmake_test_flags}" "${TMPFILE}.c" >> cmake_bootstrap.log 2>&1; then
      cmake_need_Ae=1
    fi
  fi
  if [ "x${cmake_need_Ae}" = "x1" ]; then
    cmake_c_flags="${cmake_c_flags} ${cmake_test_flags}"
    echo "${cmake_c_compiler} needs ${cmake_test_flags}"
  else
    echo "${cmake_c_compiler} does not need ${cmake_test_flags}"
  fi
  rm -f "${TMPFILE}.c"
fi
cmake_test_flags=

# Test for kwsys features
KWSYS_NAME_IS_KWSYS=0
KWSYS_BUILD_SHARED=0
KWSYS_IOS_USE_STRSTREAM_H=0
KWSYS_IOS_USE_STRSTREA_H=0
KWSYS_IOS_HAVE_STD=0
KWSYS_IOS_USE_SSTREAM=0
KWSYS_IOS_USE_ANSI=0
KWSYS_STL_HAVE_STD=0

if cmake_try_run "${cmake_cxx_compiler}" \
  "${cmake_cxx_flags} -DTEST_KWSYS_STL_HAVE_STD" \
  "${cmake_source_dir}/Source/kwsys/kwsysPlatformCxxTests.cxx" >> cmake_bootstrap.log 2>&1; then
  KWSYS_STL_HAVE_STD=1
  echo "${cmake_cxx_compiler} has STL in std:: namespace"
else
  echo "${cmake_cxx_compiler} does not have STL in std:: namespace"
fi

if cmake_try_run "${cmake_cxx_compiler}" \
  "${cmake_cxx_flags} -DTEST_KWSYS_IOS_USE_ANSI" \
  "${cmake_source_dir}/Source/kwsys/kwsysPlatformCxxTests.cxx" >> cmake_bootstrap.log 2>&1; then
  KWSYS_IOS_USE_ANSI=1
  echo "${cmake_cxx_compiler} has ANSI streams"
else
  echo "${cmake_cxx_compiler} does not have ANSI streams"
fi

if [ "x$KWSYS_IOS_USE_ANSI" = "x1" ]; then
  if cmake_try_run "${cmake_cxx_compiler}" \
    "${cmake_cxx_flags} -DTEST_KWSYS_IOS_HAVE_STD" \
    "${cmake_source_dir}/Source/kwsys/kwsysPlatformCxxTests.cxx" >> cmake_bootstrap.log 2>&1; then
    KWSYS_IOS_HAVE_STD=1
    echo "${cmake_cxx_compiler} has streams in std:: namespace"
  else
    echo "${cmake_cxx_compiler} does not have streams in std:: namespace"
  fi
  if cmake_try_run "${cmake_cxx_compiler}" \
    "${cmake_cxx_flags} -DTEST_KWSYS_IOS_USE_SSTREAM" \
    "${cmake_source_dir}/Source/kwsys/kwsysPlatformCxxTests.cxx" >> cmake_bootstrap.log 2>&1; then
    KWSYS_IOS_USE_SSTREAM=1
    echo "${cmake_cxx_compiler} has sstream"
  else
    echo "${cmake_cxx_compiler} does not have sstream"
  fi
fi

if [ "x$KWSYS_IOS_USE_SSTREAM" = "x0" ]; then
  if cmake_try_run "${cmake_cxx_compiler}" \
    "${cmake_cxx_flags} -DTEST_KWSYS_IOS_USE_STRSTREAM_H" \
    "${cmake_source_dir}/Source/kwsys/kwsysPlatformCxxTests.cxx" >> cmake_bootstrap.log 2>&1; then
    KWSYS_IOS_USE_STRSTREAM_H=1
    echo "${cmake_cxx_compiler} has strstream.h"
  else
    echo "${cmake_cxx_compiler} does not have strstream.h"
  fi
  if [ "x$KWSYS_IOS_USE_STRSTREAM_H" = "x0" ]; then
    if cmake_try_run "${cmake_cxx_compiler}" \
      "${cmake_cxx_flags} -DTEST_KWSYS_IOS_USE_STRSTREA_H" \
      "${cmake_source_dir}/Source/kwsys/kwsysPlatformCxxTests.cxx" >> cmake_bootstrap.log 2>&1; then
      KWSYS_IOS_USE_STRSTREA_H=1
      echo "${cmake_cxx_compiler} has strstrea.h"
    else
      echo "${cmake_cxx_compiler} does not have strstrea.h"
    fi
  fi
fi

# Just to be safe, let us store compiler and flags to the header file

cmake_bootstrap_version='$Revision$'
cmake_compiler_settings_comment="/*
 * Generated by ${cmake_source_dir}/bootstrap
 * Version:     ${cmake_bootstrap_version}
 *
 * Source directory: ${cmake_source_dir}
 * Binary directory: ${cmake_bootstrap_dir}
 *
 * C compiler:   ${cmake_c_compiler}
 * C flags:      ${cmake_c_flags}
 *
 * C++ compiler: ${cmake_cxx_compiler}
 * C++ flags:    ${cmake_cxx_flags}
 *
 * Make:         ${cmake_make_processor}
 *
 * Sources:
 * ${CMAKE_CXX_SOURCES} ${CMAKE_C_SOURCES}
 * kwSys Sources:
 * ${KWSYS_CXX_SOURCES} ${KWSYS_C_SOURCES}
 */
"

cmake_report cmConfigure.h.tmp "${cmake_compiler_settings_comment}"

if [ "x$KWSYS_STL_HAVE_STD" = "x1" ]; then
  cmake_report cmConfigure.h.tmp "/* #undef CMAKE_NO_STD_NAMESPACE */"
else
  cmake_report cmConfigure.h.tmp "#define CMAKE_NO_STD_NAMESPACE 1"
fi

if [ "x$KWSYS_IOS_USE_ANSI" = "x1" ]; then
  cmake_report cmConfigure.h.tmp "/* #undef CMAKE_NO_ANSI_STREAM_HEADERS */"
else
  cmake_report cmConfigure.h.tmp "#define CMAKE_NO_ANSI_STREAM_HEADERS 1"
fi

if [ "x$KWSYS_IOS_USE_SSTREAM" = "x1" ]; then
  cmake_report cmConfigure.h.tmp "/* #undef CMAKE_NO_ANSI_STRING_STREAM */"
else
  cmake_report cmConfigure.h.tmp "#define CMAKE_NO_ANSI_STRING_STREAM 1"
fi

# Test for ansi FOR scope
if cmake_try_run "${cmake_cxx_compiler}" \
  "${cmake_cxx_flags}" \
  "${cmake_source_dir}/Modules/TestForAnsiForScope.cxx" >> cmake_bootstrap.log 2>&1; then
  cmake_report cmConfigure.h.tmp "/* #undef CMAKE_NO_ANSI_FOR_SCOPE */"
  echo "${cmake_cxx_compiler} has ANSI for scoping"
else
  cmake_report cmConfigure.h.tmp "#define CMAKE_NO_ANSI_FOR_SCOPE 1"
  echo "${cmake_cxx_compiler} does not have ANSI for scoping"
fi

# Write CMake version
for a in MAJOR MINOR PATCH; do
  CMake_VERSION=`cat "${cmake_source_dir}/CMakeLists.txt" | \
    grep "SET(CMake_VERSION_${a} *[0-9]*)" | sed "s/SET(CMake_VERSION_${a} *\([0-9]*\))/\1/"`
  cmake_report cmConfigure.h.tmp "#define CMake_VERSION_${a} ${CMake_VERSION}"
done
cmake_report cmConfigure.h.tmp "#define CMAKE_ROOT_DIR \"${cmake_source_dir}\""
cmake_report cmConfigure.h.tmp "#define CMAKE_DATA_DIR \"${cmake_data_dir}\""
cmake_report cmConfigure.h.tmp "#define CMAKE_BOOTSTRAP"

# Regenerate real cmConfigure.h
if diff cmConfigure.h cmConfigure.h.tmp > /dev/null 2> /dev/null; then
  rm -f cmConfigure.h.tmp
else
  mv -f cmConfigure.h.tmp cmConfigure.h
fi

# Prepare KWSYS
cmake_kwsys_config_replace_string \
  "${cmake_source_dir}/Source/kwsys/Configure.hxx.in" \
  "${cmake_bootstrap_dir}/cmsys/Configure.hxx" \
  "${cmake_compiler_settings_comment}"
cmake_kwsys_config_replace_string \
  "${cmake_source_dir}/Source/kwsys/Configure.h.in" \
  "${cmake_bootstrap_dir}/cmsys/Configure.h" \
  "${cmake_compiler_settings_comment}"

for a in ${KWSYS_FILES}; do 
  cmake_replace_string "${cmake_source_dir}/Source/kwsys/${a}.in" \
     "${cmake_bootstrap_dir}/cmsys/${a}" KWSYS_NAMESPACE cmsys
done

for a in ${KWSYS_IOS_FILES}; do 
  cmake_replace_string "${cmake_source_dir}/Source/kwsys/kwsys_ios_${a}.h.in" \
     "${cmake_bootstrap_dir}/cmsys/ios/${a}" KWSYS_NAMESPACE cmsys
done

cmake_replace_string "${cmake_source_dir}/Source/kwsys/kwsys_stl.h.in" \
   "${cmake_bootstrap_dir}/cmsys/stl/stl.h.in" KWSYS_NAMESPACE cmsys

for a in string vector; do
  cmake_replace_string "${cmake_bootstrap_dir}/cmsys/stl/stl.h.in" \
    "${cmake_bootstrap_dir}/cmsys/stl/${a}" KWSYS_STL_HEADER ${a}
done

# Generate Makefile
dep="cmConfigure.h cmsys/Configure.hxx cmsys/Configure.h `cmake_escape \"${cmake_source_dir}\"`/Source/*.h"
objs=""
for a in ${CMAKE_CXX_SOURCES} ${CMAKE_C_SOURCES} ${KWSYS_CXX_SOURCES} ${KWSYS_C_SOURCES}; do
  objs="${objs} ${a}.o"
done

if [ "x${cmake_ansi_cxx_flags}" != "x" ]; then
  cmake_cxx_flags="${cmake_ansi_cxx_flags} ${cmake_cxx_flags}"
fi

if [ "x${cmake_c_flags}" != "x" ]; then
  cmake_c_flags="${cmake_c_flags} "
fi

if [ "x${cmake_cxx_flags}" != "x" ]; then
  cmake_cxx_flags="${cmake_cxx_flags} "
fi

cmake_c_flags="${cmake_c_flags}-I`cmake_escape \"${cmake_source_dir}/Source\"` \
  -I`cmake_escape \"${cmake_bootstrap_dir}\"`"
cmake_cxx_flags="${cmake_cxx_flags}-I`cmake_escape \"${cmake_source_dir}/Source\"` \
  -I`cmake_escape \"${cmake_bootstrap_dir}\"`"
echo "cmake: ${objs}" > "${cmake_bootstrap_dir}/Makefile"
echo "	${cmake_cxx_compiler} ${LDFLAGS} ${cmake_cxx_flags} ${objs} -o cmake" >> "${cmake_bootstrap_dir}/Makefile"
for a in ${CMAKE_CXX_SOURCES}; do
  src=`cmake_escape "${cmake_source_dir}/Source/${a}.cxx"`
  echo "${a}.o : ${src} ${dep}" >> "${cmake_bootstrap_dir}/Makefile"
  echo "	${cmake_cxx_compiler} ${cmake_cxx_flags} -c ${src} -o ${a}.o" >> "${cmake_bootstrap_dir}/Makefile"
done
for a in ${CMAKE_C_SOURCES}; do
  src=`cmake_escape "${cmake_source_dir}/Source/${a}.c"`
  echo "${a}.o : ${src} ${dep}" >> "${cmake_bootstrap_dir}/Makefile"
  echo "	${cmake_c_compiler} ${cmake_c_flags} -c ${src} -o ${a}.o" >> "${cmake_bootstrap_dir}/Makefile"
done
for a in ${KWSYS_C_SOURCES}; do
  src=`cmake_escape "${cmake_source_dir}/Source/kwsys/${a}.c"`
  echo "${a}.o : ${src} ${dep}" >> "${cmake_bootstrap_dir}/Makefile"
  echo "	${cmake_c_compiler} ${cmake_c_flags} -DKWSYS_NAMESPACE=cmsys -c ${src} -o ${a}.o" >> "${cmake_bootstrap_dir}/Makefile"
done
for a in ${KWSYS_CXX_SOURCES}; do
  src=`cmake_escape "${cmake_source_dir}/Source/kwsys/${a}.cxx"`
  echo "${a}.o : ${src} ${dep}" >> "${cmake_bootstrap_dir}/Makefile"
  echo "	${cmake_cxx_compiler} ${cmake_cxx_flags} -DKWSYS_NAMESPACE=cmsys -c ${src} -o ${a}.o" >> "${cmake_bootstrap_dir}/Makefile"
done
cat>>"${cmake_bootstrap_dir}/Makefile"<<EOF
rebuild_cache:
	cd "${cmake_binary_dir}" && "${cmake_source_dir}/bootstrap"
EOF

# Write our default settings to Bootstrap.cmk/InitialCacheFlags.cmake.
cat > "${cmake_bootstrap_dir}/InitialCacheFlags.cmake" <<EOF
# Generated by ${cmake_source_dir}/bootstrap
# Default cmake settings.  These may be overridden any settings below.
SET (CMAKE_INSTALL_PREFIX "${cmake_prefix_dir}" CACHE PATH "Install path prefix, prepended onto install directories." FORCE)
SET (CMAKE_DOC_DIR "${cmake_doc_dir}" CACHE PATH "Install location for documentation (relative to prefix)." FORCE)
SET (CMAKE_MAN_DIR "${cmake_man_dir}" CACHE PATH "Install location for man pages (relative to prefix)." FORCE)
SET (CMAKE_DATA_DIR "${cmake_data_dir}" CACHE PATH "Install location for data (relative to prefix)." FORCE)
EOF

# Add user-specified settings.  Handle relative-path case for
# specification of cmake_init_file.
(
cd "${cmake_binary_dir}"
if [ -f "${cmake_init_file}" ]; then
  cat "${cmake_init_file}" >> "${cmake_bootstrap_dir}/InitialCacheFlags.cmake"
fi
)

echo "---------------------------------------------"

# Run make to build bootstrap cmake
if [ "x${cmake_parallel_make}" != "x" ]; then
  ${cmake_make_processor} ${cmake_make_flags}
else
  ${cmake_make_processor}
fi
RES=$?
if [ "${RES}" -ne "0" ]; then
  cmake_error 9 "Problem while running ${cmake_make_processor}"
fi
cd "${cmake_binary_dir}"

# Set C, CXX, and MAKE environment variables, so that real real cmake will be
# build with same compiler and make
CC="${cmake_c_compiler}"
CXX="${cmake_cxx_compiler}"
MAKE="${cmake_make_processor}"
export CC
export CXX
export MAKE

# Run bootstrap CMake to configure real CMake
"${cmake_bootstrap_dir}/cmake" "${cmake_source_dir}" "-C${cmake_bootstrap_dir}/InitialCacheFlags.cmake"

echo "---------------------------------------------"

# And we are done. Now just run make
echo "CMake has bootstrapped.  Now run ${cmake_make_processor}."
