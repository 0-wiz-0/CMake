#!/bin/sh

#=========================================================================
#
#  Program:   CMake - Cross-Platform Makefile Generator
#  Module:    $RCSfile$
#  Language:  Bourne Shell
#  Date:      $Date$
#  Version:   $Revision$
#
#  Copyright (c) 2002 Kitware, Inc., Insight Consortium.  All rights reserved.
#  See Copyright.txt or http://www.cmake.org/HTML/Copyright.html for details.
#
#     This software is distributed WITHOUT ANY WARRANTY; without even 
#     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
#     PURPOSE.  See the above copyright notices for more information.
#
#=========================================================================

CMAKE_KNOWN_C_COMPILERS="cc gcc xlc icc tcc"
CMAKE_KNOWN_CXX_COMPILERS="CC g++ c++ xlC icc como aCC"
CMAKE_KNOWN_MAKE_PROCESSORS="make gmake"

CMAKE_SOURCES="\
  cmake  \
  cmakewizard  \
  cmakemain \
  cmMakeDepend \
  cmMakefile \
  cmDocumentation \
  cmGlobalGenerator \
  cmLocalGenerator \
  cmRegularExpression \
  cmSourceFile \
  cmSystemTools \
  cmDirectory \
  cmGlobalUnixMakefileGenerator \
  cmLocalUnixMakefileGenerator \
  cmCommands \
  cmTarget \
  cmCustomCommand \
  cmCacheManager \
  cmListFileCache \
  cmVariableWatch \
  cmSourceGroup"

cmake_system=`uname`

cmake_source_dir=`echo $0 | sed -n '/\//{s/\/[^\/]*$//;p;}'`
cmake_source_dir=`(cd "${cmake_source_dir}";pwd)`
cmake_binary_dir=`pwd`
cmake_bootstrap_dir="${cmake_binary_dir}/Bootstrap.cmk"

# Display CMake bootstrap usage
cmake_usage()
{
  cat<<EOF
Usage: $0 [options]
Options: [defaults in brackets after descriptions]
Configuration:
  --help                  print this message
  --version               only print version information
  --verbose               display more information
  --parallel=n            bootstrap cmake in parallel, where n is
                          number of nodes [1]

Directory and file names:
  --prefix=PREFIX         install architecture-independent files in PREFIX
                          [/usr/local]
EOF
  exit 10
}

# Display CMake bootstrap usage
cmake_version()
{
  # Get CMake version
  CMAKE_VERSION=""
  for a in MAJOR MINOR PATCH; do
    CMake_VERSION=`cat "${cmake_source_dir}/CMakeLists.txt" | grep "SET(CMake_VERSION_${a} *[0-9]*)" | sed "s/SET(CMake_VERSION_${a} *\([0-9]*\))/\1/"`
    CMAKE_VERSION="${CMAKE_VERSION}.${CMake_VERSION}" 
  done
  CMAKE_VERSION=`echo $CMAKE_VERSION | sed "s/\.\([0-9][0-9]*\)\.\([0-9][0-9]*\)\.\([0-9][0-9]*\)/\1.\2-\3/"`
  echo "CMake ${CMAKE_VERSION}, Copyright (c) 2002 Kitware, Inc., Insight Consortium"
}

# Display CMake bootstrap error, display the log file and exit
cmake_error()
{
  echo "---------------------------------------------"
  echo "Error when bootstrapping CMake:" 
  echo "$*"
  echo "---------------------------------------------"
  if [ -f cmake_bootstrap.log ]; then
    echo "Log of errors:"
    cat cmake_bootstrap.log
    echo "---------------------------------------------"
  fi
  exit 1
}

# Replace KWSYS_NAMESPACE with cmsys
cmake_replace_string ()
{
  INFILE="$1"
  OUTFILE="$2"
  SEARCHFOR="$3"
  REPLACEWITH="$4"
  if [ -f "${INFILE}" ]; then
    cat "${INFILE}" | 
      sed "s/\@${SEARCHFOR}\@/${REPLACEWITH}/g" > "${OUTFILE}.tmp"
    if [ -f "${OUTFILE}.tmp" ]; then
      if diff "${OUTFILE}" "${OUTFILE}.tmp" > /dev/null 2> /dev/null ; then
        #echo "Files are the same"
        rm -f "${OUTFILE}.tmp"
      else
        mv -f "${OUTFILE}.tmp" "${OUTFILE}"
      fi
    fi
  fi
}

# Write string into a file
cmake_report ()
{
  FILE=$1
  shift
  echo "$*" >> ${FILE}
}

# Escape spaces in strings
cmake_escape ()
{
  echo $1 | sed "s/ /\\\\ /g"
}

# Write message to the log
cmake_log ()
{
  echo "$*" >> cmake_bootstrap.log
}

# Return temp file
cmake_tmp_file ()
{
  echo "cmake_bootstrap_$$.test"
}

# Run a compiler test. First argument is compiler, second one are compiler
# flags, third one is test source file to be compiled
cmake_try_run ()
{
  COMPILER=$1
  FLAGS=$2
  TESTFILE=$3
  if [ ! -f "${TESTFILE}" ]; then
    echo "Test file ${TESTFILE} missing. Please verify your CMake source tree."
    exit 4
  fi
  TMPFILE=`cmake_tmp_file`
  echo "Try: ${COMPILER}"
  "${COMPILER}" ${FLAGS} "${TESTFILE}" -o "${TMPFILE}"
  RES=$?
  if [ "${RES}" -ne "0" ]; then
    echo "${COMPILER} does not work";return 1
  fi
  if [ ! -f "${TMPFILE}" ] && [ ! -f "${TMPFILE}.exe" ]; then
    echo "${COMPILER} does not produce output"
    return 2
  fi
  ./${TMPFILE}
  RES=$?
  rm -f "${TMPFILE}"
  if [ "${RES}" -ne "0" ]; then
    echo "${COMPILER} produces strange executable"
    return 3
  fi
  echo "${COMPILER} works"
  return 0
}

# Run a make test. First argument is the make interpreter.
cmake_try_make ()
{
  MAKE_PROC=$1
  echo "Try: ${MAKE_PROC}"
  ${MAKE_PROC}
  RES=$?
  if [ "${RES}" -ne "0" ]; then
    echo "${MAKE_PROC} does not work";return 1
  fi
  if [ ! -f "test" ] && [ ! -f "test.exe" ]; then
    echo "${COMPILER} does not produce output"
    return 2
  fi
  ./test
  RES=$?
  rm -f "test"
  if [ "${RES}" -ne "0" ]; then
    echo "${MAKE_PROC} produces strange executable"
    return 3
  fi
  echo "${MAKE_PROC} works"
  return 0
}

# Parse arguments
cmake_verbose=
cmake_parallel_make=
cmake_prefix_dir="/usr/local"
for a in "$@"; do
  if echo $a | grep "^--prefix=" > /dev/null 2> /dev/null; then
    cmake_prefix_dir=`echo $a | sed "s/^--prefix=//"`
  fi
  if echo $a | grep "^--parallel=" > /dev/null 2> /dev/null; then
    cmake_parallel_make=`echo $a | sed "s/^--parallel=//" | grep "[0-9][0-9]*"`
  fi
  if echo $a | grep "^--help" > /dev/null 2> /dev/null; then
    cmake_usage
  fi
  if echo $a | grep "^--version" > /dev/null 2> /dev/null; then
    cmake_version
    exit 2
  fi
  if echo $a | grep "^--verbose" > /dev/null 2> /dev/null; then
    cmake_verbose=TRUE
  fi
done

# If verbose, display some information about bootstrap
if [ -n "${cmake_verbose}" ]; then
  echo "---------------------------------------------"
  echo "Source directory: ${cmake_source_dir}"
  echo "Binary directory: ${cmake_binary_dir}"
  echo "Prefix directory: ${cmake_prefix_dir}"
  echo "System:           ${cmake_system}"
  if [ "x${cmake_parallel_make}" != "x" ]; then
    echo "Doing parallel make: ${cmake_parallel_make}"
  fi
  echo ""
fi

echo "---------------------------------------------"
# Get CMake version
echo "`cmake_version`"

# Make bootstrap directory
[ -d "${cmake_bootstrap_dir}" ] || mkdir "${cmake_bootstrap_dir}"
if [ ! -d "${cmake_bootstrap_dir}" ]; then
  cmake_error "Cannot create directory ${cmake_bootstrap_dir} to bootstrap CMake."
fi
cd "${cmake_bootstrap_dir}"

# Delete all the bootstrap files
rm -f "${cmake_bootstrap_dir}/cmake_bootstrap.log"

# If exist compiler flags, set them
cmake_c_flags=${CFLAGS}
cmake_cxx_flags=${CXXFLAGS}

# Test C compiler
cmake_c_compiler=

# If CC is set, use that for compiler, otherwise use list of known compilers
if [ -n "${CC}" ]; then
  cmake_c_compilers="${CC}"
else
  cmake_c_compilers="${CMAKE_KNOWN_C_COMPILERS}"
fi

# Check if C compiler works
TMPFILE=`cmake_tmp_file`
cat>"${TMPFILE}.c"<<EOF
#include<stdio.h>
int main()
{
  printf("1\n");
  return 0;
}
EOF
for a in ${cmake_c_compilers}; do
  if [ -z "${cmake_c_compiler}" ] && cmake_try_run "${a}" "${cmake_c_flags}" "${TMPFILE}.c" >> cmake_bootstrap.log 2>&1; then
    cmake_c_compiler="${a}"
  fi
done
rm -f "${TMPFILE}.c"

if [ -z "${cmake_c_compiler}" ]; then
  cmake_error "Cannot find apropriate C compiler on this system.
Please specify one using environment variable CC."
fi
echo "C compiler on this system is: ${cmake_c_compiler} ${cmake_c_flags}"

# Test CXX compiler
cmake_cxx_compiler=

# If CC is set, use that for compiler, otherwise use list of known compilers
if [ -n "${CXX}" ]; then
  cmake_cxx_compilers="${CXX}"
else
  cmake_cxx_compilers="${CMAKE_KNOWN_CXX_COMPILERS}"
fi

# Check if C++ compiler works
TMPFILE=`cmake_tmp_file`
cat>"${TMPFILE}.cxx"<<EOF
#include <stdio.h>
class NeedCXX {};
int main()
{
  printf("1\n");
  return 0;
}
EOF
for a in ${cmake_cxx_compilers}; do
  if [ -z "${cmake_cxx_compiler}" ] && cmake_try_run "${a}" "${cmake_cxx_flags}" "${TMPFILE}.cxx" >> cmake_bootstrap.log 2>&1; then
    cmake_cxx_compiler="${a}"
  fi
done
rm -f "${TMPFILE}.cxx"

if [ -z "${cmake_cxx_compiler}" ]; then
  cmake_error "Cannot find apropriate C++ compiler on this system.
Please specify one using environment variable CXX."
fi
echo "C++ compiler on this system is: ${cmake_cxx_compiler} ${cmake_cxx_flags}"

# Test Make

cmake_make_processor=

# If MAKE is set, use that for make processor, otherwise use list of known make
if [ -n "${MAKE}" ]; then
  cmake_make_processors="${MAKE}"
else
  cmake_make_processors="${CMAKE_KNOWN_MAKE_PROCESSORS}"
fi

TMPFILE="`cmake_tmp_file`_dir"
rm -rf "${cmake_bootstrap_dir}/${TMPFILE}"
mkdir "${cmake_bootstrap_dir}/${TMPFILE}"
cd "${cmake_bootstrap_dir}/${TMPFILE}"
cat>"Makefile"<<EOF
test: test.c
	${cmake_c_compiler} -o test test.c
EOF
cat>"test.c"<<EOF
#include <stdio.h>
int main(){ printf("1\n"); return 0; }
EOF
for a in ${cmake_make_processors}; do
  if [ -z "${cmake_make_processor}" ] && cmake_try_make "${a}" >> cmake_bootstrap.log 2>&1; then
    cmake_make_processor="${a}"
  fi
done
cd "${cmake_bootstrap_dir}"
rm -rf "${cmake_bootstrap_dir}/${TMPFILE}"

echo "Make processor on this system is: ${cmake_make_processor}"

# Ok, we have CC, CXX, and MAKE.

# Test C++ compiler features

# If we are on IRIX, check for -LANG:std
if [ "x${cmake_system}" = "xIRIX64" ]; then
  TMPFILE=`cmake_tmp_file`
  cat>${TMPFILE}.cxx<<EOF
  #include <iostream>
  int main() { std::cout << "No need for -LANG:std" << std::endl; return 0;}
EOF
  cmake_need_lang_std=0
  if cmake_try_run "${cmake_cxx_compiler}" "${cmake_cxx_flags}" "${TMPFILE}.cxx" >> cmake_bootstrap.log 2>&1; then
    :
  else
    if cmake_try_run "${cmake_cxx_compiler}" "${cmake_cxx_flags} -LANG:std" "${TMPFILE}.cxx" >> cmake_bootstrap.log 2>&1; then
      cmake_need_lang_std=1
    fi
  fi
  if [ "x${cmake_need_lang_std}" = "x1" ]; then
    cmake_cxx_flags="${cmake_cxx_flags} -LANG:std"
    echo "${cmake_cxx_compiler} needs -LANG:std"
  else
    echo "${cmake_cxx_compiler} does not need -LANG:std"
  fi
  rm -f "${TMPFILE}.cxx"
fi

# Just to be safe, let us store compiler and flags to the header file

cmake_report cmConfigure.h.tmp "/*"
cmake_report cmConfigure.h.tmp " * Generated by ${cmake_source_dir}/bootstrap"
cmake_report cmConfigure.h.tmp " * Binary directory: ${cmake_bootstrap_dir}"
cmake_report cmConfigure.h.tmp " * C compiler:   ${cmake_c_compiler}"
cmake_report cmConfigure.h.tmp " * C flags:      ${cmake_c_flags}"
cmake_report cmConfigure.h.tmp " *"
cmake_report cmConfigure.h.tmp " * C++ compiler: ${cmake_cxx_compiler}"
cmake_report cmConfigure.h.tmp " * C++ flags:    ${cmake_cxx_flags}"
cmake_report cmConfigure.h.tmp " *"
cmake_report cmConfigure.h.tmp " * Make:         ${cmake_make_processor}"
cmake_report cmConfigure.h.tmp " *"
cmake_report cmConfigure.h.tmp " * Sources:"
cmake_report cmConfigure.h.tmp " * ${CMAKE_SOURCES}"
cmake_report cmConfigure.h.tmp " */"

# Test for STD namespace
if cmake_try_run "${cmake_cxx_compiler}" "${cmake_cxx_flags}" "${cmake_source_dir}/Modules/TestForSTDNamespace.cxx" >> cmake_bootstrap.log 2>&1; then
  cmake_report cmConfigure.h.tmp "/* #undef CMAKE_NO_STD_NAMESPACE */"
  echo "${cmake_cxx_compiler} has STD namespace"
else
  cmake_report cmConfigure.h.tmp "#define CMAKE_NO_STD_NAMESPACE 1"
  echo "${cmake_cxx_compiler} does not have STD namespace"
fi

# Test for ANSI stream headers
if cmake_try_run "${cmake_cxx_compiler}" "${cmake_cxx_flags}" "${cmake_source_dir}/Modules/TestForANSIStreamHeaders.cxx" >> cmake_bootstrap.log 2>&1; then
  cmake_report cmConfigure.h.tmp "/* #undef CMAKE_NO_ANSI_STREAM_HEADERS */"
  echo "${cmake_cxx_compiler} has ANSI stream headers"
else
  cmake_report cmConfigure.h.tmp "#define CMAKE_NO_ANSI_STREAM_HEADERS 1"
  echo "${cmake_cxx_compiler} does not have ANSI stream headers"
fi

# Test for ansi string streams
TMPFILE=`cmake_tmp_file`
cat>${TMPFILE}.cxx<<EOF
#include <sstream>
int main() { return 0;}
EOF
if cmake_try_run "${cmake_cxx_compiler}" "${cmake_cxx_flags}" "${TMPFILE}.cxx" >> cmake_bootstrap.log 2>&1; then
  cmake_report cmConfigure.h.tmp "/* #undef CMAKE_NO_ANSI_STRING_STREAM */"
  echo "${cmake_cxx_compiler} has ANSI string streams"
else
  cmake_report cmConfigure.h.tmp "#define CMAKE_NO_ANSI_STRING_STREAM 1"
  echo "${cmake_cxx_compiler} does not have ANSI string streams"
fi
rm -f "${TMPFILE}.cxx"

# Test for ansi FOR scope
if cmake_try_run "${cmake_cxx_compiler}" "${cmake_cxx_flags}" "${cmake_source_dir}/Modules/TestForAnsiForScope.cxx" >> cmake_bootstrap.log 2>&1; then
  cmake_report cmConfigure.h.tmp "/* #undef CMAKE_NO_ANSI_FOR_SCOPE */"
  echo "${cmake_cxx_compiler} has ANSI for scoping"
else
  cmake_report cmConfigure.h.tmp "#define CMAKE_NO_ANSI_FOR_SCOPE 1"
  echo "${cmake_cxx_compiler} does not have ANSI for scoping"
fi

# Write CMake version
for a in MAJOR MINOR PATCH; do
  CMake_VERSION=`cat "${cmake_source_dir}/CMakeLists.txt" | grep "SET(CMake_VERSION_${a} *[0-9]*)" | sed "s/SET(CMake_VERSION_${a} *\([0-9]*\))/\1/"`
  cmake_report cmConfigure.h.tmp "#define CMake_VERSION_${a} ${CMake_VERSION}"
done
cmake_report cmConfigure.h.tmp "#define CMAKE_ROOT_DIR \"${cmake_source_dir}\""
cmake_report cmConfigure.h.tmp "#define CMAKE_BOOTSTRAP"

# Regenerate real cmConfigure.h
if diff cmConfigure.h cmConfigure.h.tmp > /dev/null 2> /dev/null; then
  rm -f cmConfigure.h.tmp
else
  mv -f cmConfigure.h.tmp cmConfigure.h
fi

# Generate Makefile
dep="cmConfigure.h `cmake_escape \"${cmake_source_dir}\"`/Source/*.h"
objs=""
for a in ${CMAKE_SOURCES}; do
  objs="${objs} ${a}.o"
done

if [ "x${cmake_ansi_cxx_flags}" != "x" ]; then
  cmake_cxx_flags="${cmake_ansi_cxx_flags} ${cmake_cxx_flags}"
fi

if [ "x${cmake_cxx_flags}" != "x" ]; then
  cmake_cxx_flags="${cmake_cxx_flags} "
fi

cmake_cxx_flags="${cmake_cxx_flags}-I`cmake_escape \"${cmake_source_dir}/Source\"` -I`cmake_escape \"${cmake_bootstrap_dir}\"`"
echo "cmake: ${objs}" > "${cmake_bootstrap_dir}/Makefile"
echo "	${cmake_cxx_compiler} ${LDFLAGS} ${cmake_cxx_flags} ${objs} -o cmake" >> "${cmake_bootstrap_dir}/Makefile"
for a in ${CMAKE_SOURCES}; do
  src=`cmake_escape "${cmake_source_dir}/Source/${a}.cxx"`
  echo "${a}.o : ${src} ${dep}" >> "${cmake_bootstrap_dir}/Makefile"
  echo "	${cmake_cxx_compiler} ${cmake_cxx_flags} -c ${src} -o ${a}.o" >> "${cmake_bootstrap_dir}/Makefile"
done

# Write prefix to Bootstrap.cmk/InitialConfigureFlags.cmake
echo "SET (CMAKE_CONFIGURE_INSTALL_PREFIX \"${cmake_prefix_dir}\" CACHE PATH \"Install path prefix, prepended onto install directories, For CMake this will always override CMAKE_INSTALL_PREFIX in the cache.\")" > "${cmake_bootstrap_dir}/InitialConfigureFlags.cmake"

echo "---------------------------------------------"

# Run make to build bootstrap cmake
if [ "x${cmake_parallel_make}" != "x" ]; then
  ${cmake_make_processor} -j ${cmake_parallel_make}
else
  ${cmake_make_processor}
fi
RES=$?
if [ "${RES}" -ne "0" ]; then
  cmake_error "Problem while bootstrapping CMake"
fi
cd "${cmake_binary_dir}"

# Set C, CXX, and MAKE environment variables, so that real real cmake will be
# build with same compiler and make
CC="${cmake_c_compiler}"
CXX="${cmake_cxx_compiler}"
MAKE="${cmake_make_processor}"
export CC
export CXX
export MAKE

# Run bootstrap CMake to configure real CMake
"${cmake_bootstrap_dir}/cmake" "${cmake_source_dir}"

echo "---------------------------------------------"

# And we are done. Now just run make
echo "CMake is configured. Now just run ${cmake_make_processor}."
